<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truth Table Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .app-content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 1.2rem;
            color: #2c3e50;
        }

        #expressionInput {
            width: 100%;
            padding: 15px;
            font-size: 1.3rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s;
        }

        #expressionInput:focus {
            border-color: #3498db;
        }

        .symbols-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .symbols-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .symbol-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .symbol-btn {
            padding: 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
        }

        .symbol-btn:hover {
            background: #2980b9;
        }

        .symbol-btn:active {
            transform: scale(0.98);
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .control-btn {
            padding: 12px 25px;
            font-size: 1.1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #generateBtn {
            background: #27ae60;
            color: white;
            flex: 2;
        }

        #generateBtn:hover {
            background: #219653;
        }

        #clearBtn {
            background: #e74c3c;
            color: white;
            flex: 1;
        }

        #clearBtn:hover {
            background: #c0392b;
        }

        .preview-section {
            background: #f1f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }

        .preview-label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        #expressionPreview {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2980b9;
            min-height: 30px;
        }

        .table-section {
            margin-top: 30px;
        }

        .table-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
        }

        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #dfe6ee;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #truthTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 1.2rem;
        }

        th {
            background: #34495e;
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: 600;
            border-bottom: 2px solid #4a627a;
        }

        #truthTable td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #dfe6ee;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tr:hover {
            background-color: #e8f4fc;
        }

        .main-operator-header {
            background-color: #ffd700 !important; /* Gold */
            color: #3d3d3d !important;
        }

        .main-operator-col {
            background-color: #fffacd !important; /* LemonChiffon - a light gold */
        }

        .true-cell {
            background-color: #d4edda;
            color: #155724;
            font-weight: 600;
        }

        .false-cell {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: 600;
        }

        .result-separator {
            border-left: 2px solid #2c3e50 !important;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #e74c3c;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #27ae60;
        }

        @media (max-width: 768px) {
            .symbol-buttons {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            th, td {
                padding: 10px 5px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Truth Table Generator</h1>
            <div class="subtitle">Create truth tables for logical expressions</div>
        </header>
        
        <div class="app-content">
            <section class="input-section">
                <div class="input-group">
                    <label for="expressionInput">Enter Logical Expression:</label>
                    <input type="text" id="expressionInput" placeholder="e.g., (P & (Q v ~R))" autofocus>
                </div>
                
                <div class="symbols-container">
                    <div class="symbols-title">Logical Symbols:</div>
                    <div class="symbol-buttons">
                        <button class="symbol-btn" data-symbol="~">~ (Tilde)</button>
                        <button class="symbol-btn" data-symbol="&">& (Ampersand)</button>
                        <button class="symbol-btn" data-symbol="v">v (Wedge)</button>
                        <button class="symbol-btn" data-symbol="→">→ (Arrow)</button>
                        <button class="symbol-btn" data-symbol="↔">↔ (Double Arrow)</button>
                        <button class="symbol-btn" id="clearInputBtn">Clear Input</button>
                    </div>
                </div>
                
                <div class="preview-section">
                    <div class="preview-label">Expression Preview:</div>
                    <div id="expressionPreview"></div>
                </div>
                
                <div class="control-buttons">
                    <button class="control-btn" id="generateBtn">Generate Truth Table</button>
                    <button class="control-btn" id="clearBtn">Clear Table</button>
                </div>
            </section>
            
            <section class="table-section">
                <div class="table-title">Truth Table</div>
                <div class="table-container">
                    <table id="truthTable">
                        <!-- Table will be generated here -->
                    </table>
                </div>
            </section>
            
            <div id="messageArea"></div>
        </div>
    </div>

    <script>
        class TruthTableGenerator {
            constructor() {
                this.operators = {
                    '&': { precedence: 3, eval: (a, b) => a && b, type: 'binary' },
                    'v': { precedence: 2, eval: (a, b) => a || b, type: 'binary' },
                    '→': { precedence: 1, eval: (a, b) => !a || b, type: 'binary' },
                    '↔': { precedence: 0, eval: (a, b) => a === b, type: 'binary' },
                    '~': { precedence: 4, eval: a => !a, type: 'unary' }
                };
                
                this.initializeEventListeners();
                this.updatePreview();
            }
            
            initializeEventListeners() {
                // Symbol buttons
                document.querySelectorAll('.symbol-btn[data-symbol]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.insertSymbol(btn.getAttribute('data-symbol'));
                    });
                });
                
                // Clear input button
                document.getElementById('clearInputBtn').addEventListener('click', () => {
                    this.clearInput();
                });
                
                // Generate button
                document.getElementById('generateBtn').addEventListener('click', () => {
                    this.generateTruthTable();
                });
                
                // Clear table button
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearAll();
                });
                
                // Input field events
                const expressionInput = document.getElementById('expressionInput');
                expressionInput.addEventListener('input', () => {
                    this.updatePreview();
                });
                
                expressionInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.generateTruthTable();
                    }
                });
            }
            
            insertSymbol(symbol) {
                const input = document.getElementById('expressionInput');
                const start = input.selectionStart;
                const end = input.selectionEnd;
                const value = input.value;
                
                input.value = value.substring(0, start) + symbol + value.substring(end);
                input.selectionStart = input.selectionEnd = start + symbol.length;
                input.focus();
                
                this.updatePreview();
            }
            
            clearInput() {
                document.getElementById('expressionInput').value = '';
                document.getElementById('expressionInput').focus();
                this.updatePreview();
            }
            
            clearAll() {
                this.clearInput();
                document.getElementById('truthTable').innerHTML = '';
                this.clearMessage();
            }
            
            updatePreview() {
                const expression = document.getElementById('expressionInput').value;
                const preview = document.getElementById('expressionPreview');
                
                if (expression.trim()) {
                    // Format the expression with spacing for better readability
                    let formatted = expression
                        .replace(/([&v→↔])/g, ' $1 ')
                        .replace(/(~)\s*/g, '$1')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    preview.textContent = formatted;
                } else {
                    preview.textContent = '';
                }
            }
            
            getVariables(expression) {
                // Remove all operators and parentheses, then find unique letters
                const cleanExpr = expression.replace(/[^A-Z]/g, '');
                const variables = [...new Set(cleanExpr)];
                return variables.sort();
            }
            
            tokenize(expression) {
                // Convert expression to tokens (variables, operators, parentheses)
                // Add spaces around all operators and parentheses to ensure they are tokenized correctly
                const spacedExpression = expression
                    .replace(/([&v→↔~()])/g, ' $1 ')
                    .trim();

                // Split by spaces and filter out any empty strings
                const tokens = spacedExpression.split(/\s+/).filter(token => token.length > 0);

                return tokens;
            }
            
            infixToPostfix(tokens) {
                const output = [];
                const stack = [];
                
                for (let token of tokens) {
                    if (token in this.operators) {
                        if (this.operators[token].type === 'unary') {
                            // Unary operators (like ¬) have highest precedence and are right-associative
                            stack.push(token);
                        } else {
                            // Binary operators
                            while (stack.length > 0 && 
                                   stack[stack.length - 1] !== '(' &&
                                   this.operators[token].precedence <= this.operators[stack[stack.length - 1]].precedence) {
                                output.push(stack.pop());
                            }
                            stack.push(token);
                        }
                    } else if (token === '(') {
                        stack.push(token);
                    } else if (token === ')') {
                        while (stack.length > 0 && stack[stack.length - 1] !== '(') {
                            output.push(stack.pop());
                        }
                        if (stack.length > 0 && stack[stack.length - 1] === '(') {
                            stack.pop(); // Remove '('
                        }
                    } else {
                        output.push(token); // Variable
                    }
                }
                
                while (stack.length > 0) {
                    output.push(stack.pop());
                }
                
                return output;
            }
            
            evaluatePostfix(postfix, values) {
                const stack = [];
                
                for (let token of postfix) {
                    if (token in this.operators) {
                        if (this.operators[token].type === 'unary') {
                            const operand = stack.pop();
                            stack.push(this.operators[token].eval(operand));
                        } else {
                            const right = stack.pop();
                            const left = stack.pop();
                            stack.push(this.operators[token].eval(left, right));
                        }
                    } else {
                        stack.push(values[token]);
                    }
                }
                
                return stack[0];
            }
            
            generateTruthTable() {
                const expression = document.getElementById('expressionInput').value.trim();
                
                if (!expression) {
                    this.showMessage('Please enter a logical expression.', 'error');
                    return;
                }
                
                // Validate for lowercase variables (excluding 'v' for OR)
                const invalidChars = expression.match(/[a-uw-z]/g);
                if (invalidChars) {
                    this.showMessage(`Invalid characters found: ${[...new Set(invalidChars)].join(', ')}. Variables must be uppercase letters.`, 'error');
                    return;
                }

                if (!this.isWellFormed(expression)) {
                    this.showMessage('Expression is not well-formed. All binary operations (e.g., A & B) must be enclosed in parentheses like (A & B).', 'error');
                    return;
                }

                const variables = this.getVariables(expression);
                
                if (variables.length === 0) {
                    this.showMessage('No variables found in the expression.', 'error');
                    return;
                }
                
                try {
                    const tokens = this.tokenize(expression);
                    const postfix = this.infixToPostfix(tokens);

                    // Find the main operator to highlight it
                    let mainOperatorIndex = -1;
                    if (postfix.length > 0) {
                        const mainOperatorToken = postfix[postfix.length - 1];
                        if (mainOperatorToken in this.operators) {
                            // Find the last occurrence of this operator in the original tokens
                            // This is a simple way to find it, works for many cases.
                            for (let i = tokens.length - 1; i >= 0; i--) {
                                if (tokens[i] === mainOperatorToken) {
                                    mainOperatorIndex = i;
                                    break;
                                }
                            }
                        } else if (tokens.length === 1) { // Case for a single variable like "P"
                            mainOperatorIndex = 0;
                        }
                    }
                    
                    // Generate all possible truth value combinations (starting with true)
                    const combinations = this.generateCombinations(variables.length);
                    
                    // Create the truth table
                    this.renderTruthTable(variables, tokens, combinations, postfix, mainOperatorIndex);
                    this.showMessage(`Truth table generated successfully for: ${expression}`, 'success');
                    
                } catch (error) {
                    this.showMessage(`Error: ${error.message}`, 'error');
                    console.error(error);
                }
            }
            
            generateCombinations(n) {
                const total = Math.pow(2, n);
                const combinations = [];
                
                for (let i = 0; i < total; i++) {
                    const combination = [];
                    // Start with true values first (reverse the bit order)
                    for (let j = n - 1; j >= 0; j--) {
                        // Use bit manipulation to get the value, but reverse the order
                        combination.push(Boolean(i & (1 << j)));
                    }
                    combinations.push(combination);
                }
                
                // Reverse the entire array to start with all true values
                return combinations.reverse();
            }
            
            isWellFormed(expression) {
                // A single uppercase letter is a valid WFF.
                if (/^[A-Z]$/.test(expression.trim())) {
                    return true;
                }

                let balance = 0;
                for (const char of expression) {
                    if (char === '(') balance++;
                    else if (char === ')') balance--;
                    if (balance < 0) return false; // Closing parenthesis before an opening one
                }
                if (balance !== 0) return false; // Unbalanced parentheses

                // Check for binary operators outside of parentheses
                balance = 0;
                for (const char of expression) {
                    if (char === '(') balance++;
                    else if (char === ')') balance--;
                    else if (balance === 0 && '&v→↔'.includes(char)) return false;
                }
                return true;
            }

            renderTruthTable(variables, expressionTokens, combinations, postfix, mainOperatorIndex) {
                const table = document.getElementById('truthTable');
                table.innerHTML = '';
                
                // Create header row
                const headerRow = document.createElement('tr');
                
                variables.forEach(variable => {
                    const th = document.createElement('th'); th.textContent = variable; headerRow.appendChild(th);
                });
                
                // Pre-process tokens to merge parentheses for display
                let displayTokens = [...expressionTokens];
                // Merge right parentheses (backwards)
                for (let i = displayTokens.length - 1; i >= 0; i--) {
                    if (displayTokens[i] === ')') {
                        for (let j = i - 1; j >= 0; j--) {
                            if (displayTokens[j] && !['(', ')'].includes(displayTokens[j])) {
                                displayTokens[j] += ')';
                                displayTokens[i] = null;
                                break;
                            }
                        }
                    }
                }
                // Merge left parentheses (forwards)
                for (let i = 0; i < displayTokens.length; i++) {
                    if (displayTokens[i] === '(') {
                        for (let j = i + 1; j < displayTokens.length; j++) {
                            if (displayTokens[j] && !['(', ')'].includes(displayTokens[j])) {
                                displayTokens[j] = '(' + displayTokens[j];
                                displayTokens[i] = null;
                                break;
                            }
                        }
                    }
                }

                displayTokens.forEach((token, index) => {
                    if (token === null) return; // Skip merged parentheses
                    const th = document.createElement('th');
                    th.textContent = token;
                    th.classList.add('result-separator');
                    th.style.minWidth = '30px';
                    if (index === mainOperatorIndex) {
                        th.classList.add('main-operator-header');
                    }
                    headerRow.appendChild(th);
                });
                
                table.appendChild(headerRow);
                
                // Create data rows
                combinations.forEach(combo => {
                    const row = document.createElement('tr');
                    const values = {};
                    
                    // Add variable values
                    variables.forEach((variable, index) => {
                        values[variable] = combo[index];
                        
                        const td = document.createElement('td');
                        td.textContent = combo[index] ? 'T' : 'F';
                        td.className = combo[index] ? 'true-cell' : 'false-cell';
                        row.appendChild(td);
                    });
                    
                    // Calculate and add result
                    try {
                        const allResults = this.evaluateWithIntermediateSteps(expressionTokens, postfix, values);
                        
                        expressionTokens.forEach((token, index) => {
                            if (displayTokens[index] === null) return; // Don't create a cell for a merged parenthesis

                            const td = document.createElement('td');
                            td.classList.add('result-separator');
                            if (index === mainOperatorIndex) {
                                td.classList.add('main-operator-col');
                            }
                            
                            if (index in allResults) {
                                const result = allResults[index];
                                td.textContent = result ? 'T' : 'F';
                                td.classList.add(result ? 'true-cell' : 'false-cell');
                            } // else: it's a parenthesis that wasn't merged, leave cell blank
                            row.appendChild(td);
                        });

                    } catch (error) {
                        const resultTd = document.createElement('td');
                        resultTd.textContent = 'Error';
                        resultTd.className = 'false-cell';
                        resultTd.colSpan = expressionTokens.length;
                        resultTd.classList.add('result-separator');
                        row.appendChild(resultTd);
                    }
                    
                    table.appendChild(row);
                });
            }

            evaluateWithIntermediateSteps(expressionTokens, postfix, values) {
                const stack = [];
                const results = {}; // Store results by original token index

                // Create a map from postfix token to its original index
                const tokenIndices = {};
                const tempTokens = [...expressionTokens];
                for (const pToken of postfix) {
                    if (pToken in this.operators || pToken in values) {
                        const idx = tempTokens.indexOf(pToken);
                        if (!tokenIndices[pToken]) tokenIndices[pToken] = [];
                        tokenIndices[pToken].push(idx);
                        tempTokens[idx] = null; // Mark as used
                    }
                }

                for (const pToken of postfix) {
                    if (pToken in values) {
                        const val = values[pToken];
                        const idx = tokenIndices[pToken].shift();
                        results[idx] = val;
                        stack.push({ token: pToken, value: val });
                    } else if (pToken in this.operators) {
                        const opInfo = this.operators[pToken];
                        const opIdx = tokenIndices[pToken].shift();
                        let result;
                        if (opInfo.type === 'unary') {
                            const operand = stack.pop();
                            result = opInfo.eval(operand.value);
                        } else {
                            const right = stack.pop();
                            const left = stack.pop();
                            result = opInfo.eval(left.value, right.value);
                        }
                        results[opIdx] = result;
                        stack.push({ token: pToken, value: result });
                    }
                }
                return results;
            }
            
            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea');
                messageArea.innerHTML = `<div class="${type}-message">${message}</div>`;
                
                // Auto-hide success messages after 5 seconds
                if (type === 'success') {
                    setTimeout(() => {
                        this.clearMessage();
                    }, 5000);
                }
            }
            
            clearMessage() {
                document.getElementById('messageArea').innerHTML = '';
            }
        }
        
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TruthTableGenerator();
        });
    </script>
</body>
</html>