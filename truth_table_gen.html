<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truth Table Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .app-content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 1.2rem;
            color: #2c3e50;
        }

        #expressionInput {
            width: 100%;
            padding: 15px;
            font-size: 1.3rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s;
        }

        #expressionInput:focus {
            border-color: #3498db;
        }

        .symbols-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .symbols-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .symbol-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .symbol-btn {
            padding: 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
        }

        .symbol-btn:hover {
            background: #2980b9;
        }

        .symbol-btn:active {
            transform: scale(0.98);
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .control-btn {
            padding: 12px 25px;
            font-size: 1.1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #generateBtn {
            background: #27ae60;
            color: white;
            flex: 2;
        }

        #generateBtn:hover {
            background: #219653;
        }

        #clearBtn {
            background: #e74c3c;
            color: white;
            flex: 1;
        }

        #clearBtn:hover {
            background: #c0392b;
        }

        .preview-section {
            background: #f1f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }

        .preview-label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        #expressionPreview {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2980b9;
            min-height: 30px;
        }

        .table-section {
            margin-top: 30px;
        }

        .table-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
        }

        .table-container {
            overflow-x: auto;
            border: 1px solid white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1.2rem;
        }

        th {
            background: #34495e;
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: 600;
            border: 1px solid #2c3e50;
        }

        td {
            padding: 12px;
            text-align: center;
            border: 1px solid #535353;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tr:hover {
            background-color: #e8f4fc;
        }

        .true-cell {
            background-color: #d4edda;
            color: #155724;
            font-weight: 600;
        }

        .false-cell {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: 600;
        }

        .result-separator {
            border-left: 3px solid #2c3e50 !important;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #e74c3c;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #27ae60;
        }

        @media (max-width: 768px) {
            .symbol-buttons {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            th, td {
                padding: 10px 5px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Truth Table Generator</h1>
            <div class="subtitle">Create truth tables for logical expressions</div>
        </header>
        
        <div class="app-content">
            <section class="input-section">
                <div class="input-group">
                    <label for="expressionInput">Enter Logical Expression:</label>
                    <input type="text" id="expressionInput" placeholder="e.g., (P & (Q v ~R))" autofocus>
                </div>
                
                <div class="symbols-container">
                    <div class="symbols-title">Logical Symbols:</div>
                    <div class="symbol-buttons">
                        <button class="symbol-btn" data-symbol="~">~ (Tilde)</button>
                        <button class="symbol-btn" data-symbol="&">& (Ampersand)</button>
                        <button class="symbol-btn" data-symbol="v">v (Wedge)</button>
                        <button class="symbol-btn" data-symbol="→">→ (Arrow)</button>
                        <button class="symbol-btn" data-symbol="↔">↔ (Double Arrow)</button>
                        <button class="symbol-btn" id="clearInputBtn">Clear Input</button>
                    </div>
                </div>
                
                <div class="preview-section">
                    <div class="preview-label">Expression Preview:</div>
                    <div id="expressionPreview"></div>
                </div>
                
                <div class="control-buttons">
                    <button class="control-btn" id="generateBtn">Generate Truth Table</button>
                    <button class="control-btn" id="clearBtn">Clear Table</button>
                </div>
            </section>
            
            <section class="table-section">
                <div class="table-title">Truth Table</div>
                <div class="table-container">
                    <table id="truthTable">
                        <!-- Table will be generated here -->
                    </table>
                </div>
            </section>
            
            <div id="messageArea"></div>
        </div>
    </div>

    <script>
        class TruthTableGenerator {
            constructor() {
                this.operators = {
                    '&': { precedence: 3, eval: (a, b) => a && b, type: 'binary' },
                    'v': { precedence: 2, eval: (a, b) => a || b, type: 'binary' },
                    '→': { precedence: 1, eval: (a, b) => !a || b, type: 'binary' },
                    '↔': { precedence: 0, eval: (a, b) => a === b, type: 'binary' },
                    '~': { precedence: 4, eval: a => !a, type: 'unary' }
                };
                
                this.initializeEventListeners();
                this.updatePreview();
            }
            
            initializeEventListeners() {
                // Symbol buttons
                document.querySelectorAll('.symbol-btn[data-symbol]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.insertSymbol(btn.getAttribute('data-symbol'));
                    });
                });
                
                // Clear input button
                document.getElementById('clearInputBtn').addEventListener('click', () => {
                    this.clearInput();
                });
                
                // Generate button
                document.getElementById('generateBtn').addEventListener('click', () => {
                    this.generateTruthTable();
                });
                
                // Clear table button
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearAll();
                });
                
                // Input field events
                const expressionInput = document.getElementById('expressionInput');
                expressionInput.addEventListener('input', () => {
                    this.updatePreview();
                });
                
                expressionInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.generateTruthTable();
                    }
                });
            }
            
            insertSymbol(symbol) {
                const input = document.getElementById('expressionInput');
                const start = input.selectionStart;
                const end = input.selectionEnd;
                const value = input.value;
                
                input.value = value.substring(0, start) + symbol + value.substring(end);
                input.selectionStart = input.selectionEnd = start + symbol.length;
                input.focus();
                
                this.updatePreview();
            }
            
            clearInput() {
                document.getElementById('expressionInput').value = '';
                document.getElementById('expressionInput').focus();
                this.updatePreview();
            }
            
            clearAll() {
                this.clearInput();
                document.getElementById('truthTable').innerHTML = '';
                this.clearMessage();
            }
            
            updatePreview() {
                const expression = document.getElementById('expressionInput').value;
                const preview = document.getElementById('expressionPreview');
                
                if (expression.trim()) {
                    // Format the expression with spacing for better readability
                    let formatted = expression
                        .replace(/([&v→↔])/g, ' $1 ')
                        .replace(/(~)\s*/g, '$1')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    preview.textContent = formatted;
                } else {
                    preview.textContent = '';
                }
            }
            
            getVariables(expression) {
                // Remove all operators and parentheses, then find unique letters
                const cleanExpr = expression.replace(/[&v→↔~()\s]/g, '');
                const variables = [...new Set(cleanExpr.match(/[A-Za-z]/g))];
                return variables ? variables.sort() : [];
            }
            
            tokenize(expression) {
                // Convert expression to tokens (variables, operators, parentheses)
                const tokens = [];
                let current = '';
                
                for (let char of expression.replace(/\s/g, '')) {
                    if (char.match(/[A-Za-z]/)) {
                        current += char;
                    } else {
                        if (current) {
                            tokens.push(current);
                            current = '';
                        }
                        
                        if ('&v→↔~()'.includes(char)) {
                            tokens.push(char);
                        }
                    }
                }
                
                if (current) {
                    tokens.push(current);
                }
                
                return tokens;
            }
            
            infixToPostfix(tokens) {
                const output = [];
                const stack = [];
                
                for (let token of tokens) {
                    if (token in this.operators) {
                        if (this.operators[token].type === 'unary') {
                            // Unary operators (like ¬) have highest precedence and are right-associative
                            stack.push(token);
                        } else {
                            // Binary operators
                            while (stack.length > 0 && 
                                   stack[stack.length - 1] !== '(' &&
                                   this.operators[token].precedence <= this.operators[stack[stack.length - 1]].precedence) {
                                output.push(stack.pop());
                            }
                            stack.push(token);
                        }
                    } else if (token === '(') {
                        stack.push(token);
                    } else if (token === ')') {
                        while (stack.length > 0 && stack[stack.length - 1] !== '(') {
                            output.push(stack.pop());
                        }
                        if (stack.length > 0 && stack[stack.length - 1] === '(') {
                            stack.pop(); // Remove '('
                        }
                    } else {
                        output.push(token); // Variable
                    }
                }
                
                while (stack.length > 0) {
                    output.push(stack.pop());
                }
                
                return output;
            }
            
            evaluatePostfix(postfix, values) {
                const stack = [];
                
                for (let token of postfix) {
                    if (token in this.operators) {
                        if (this.operators[token].type === 'unary') {
                            const operand = stack.pop();
                            stack.push(this.operators[token].eval(operand));
                        } else {
                            const right = stack.pop();
                            const left = stack.pop();
                            stack.push(this.operators[token].eval(left, right));
                        }
                    } else {
                        stack.push(values[token]);
                    }
                }
                
                return stack[0];
            }
            
            generateTruthTable() {
                const expression = document.getElementById('expressionInput').value.trim();
                
                if (!expression) {
                    this.showMessage('Please enter a logical expression.', 'error');
                    return;
                }
                
                const variables = this.getVariables(expression);
                
                if (variables.length === 0) {
                    this.showMessage('No variables found in the expression.', 'error');
                    return;
                }
                
                try {
                    const tokens = this.tokenize(expression);
                    const postfix = this.infixToPostfix(tokens);
                    
                    // Generate all possible truth value combinations (starting with true)
                    const combinations = this.generateCombinations(variables.length);
                    
                    // Create the truth table
                    this.renderTruthTable(variables, expression, combinations, postfix);
                    this.showMessage(`Truth table generated successfully for: ${expression}`, 'success');
                    
                } catch (error) {
                    this.showMessage(`Error: ${error.message}`, 'error');
                    console.error(error);
                }
            }
            
            generateCombinations(n) {
                const total = Math.pow(2, n);
                const combinations = [];
                
                for (let i = 0; i < total; i++) {
                    const combination = [];
                    // Start with true values first (reverse the bit order)
                    for (let j = n - 1; j >= 0; j--) {
                        // Use bit manipulation to get the value, but reverse the order
                        combination.push(Boolean(i & (1 << j)));
                    }
                    combinations.push(combination);
                }
                
                // Reverse the entire array to start with all true values
                return combinations.reverse();
            }
            
            renderTruthTable(variables, expression, combinations, postfix) {
                const table = document.getElementById('truthTable');
                table.innerHTML = '';
                
                // Create header row
                const headerRow = document.createElement('tr');
                
                variables.forEach(variable => {
                    const th = document.createElement('th');
                    th.textContent = variable;
                    headerRow.appendChild(th);
                });
                
                const resultTh = document.createElement('th');
                resultTh.textContent = expression;
                resultTh.classList.add('result-separator');
                headerRow.appendChild(resultTh);
                
                table.appendChild(headerRow);
                
                // Create data rows
                combinations.forEach(combo => {
                    const row = document.createElement('tr');
                    const values = {};
                    
                    // Add variable values
                    variables.forEach((variable, index) => {
                        values[variable] = combo[index];
                        
                        const td = document.createElement('td');
                        td.textContent = combo[index] ? 'T' : 'F';
                        td.className = combo[index] ? 'true-cell' : 'false-cell';
                        row.appendChild(td);
                    });
                    
                    // Calculate and add result
                    try {
                        const result = this.evaluatePostfix(postfix, values);
                        const resultTd = document.createElement('td');
                        resultTd.textContent = result ? 'T' : 'F';
                        resultTd.className = result ? 'true-cell' : 'false-cell'; // Base classes
                        resultTd.classList.add('result-separator');
                        row.appendChild(resultTd);
                    } catch (error) {
                        const resultTd = document.createElement('td');
                        resultTd.textContent = 'Error';
                        resultTd.className = 'false-cell';
                        resultTd.classList.add('result-separator');
                        row.appendChild(resultTd);
                    }
                    
                    table.appendChild(row);
                });
            }
            
            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea');
                messageArea.innerHTML = `<div class="${type}-message">${message}</div>`;
                
                // Auto-hide success messages after 5 seconds
                if (type === 'success') {
                    setTimeout(() => {
                        this.clearMessage();
                    }, 5000);
                }
            }
            
            clearMessage() {
                document.getElementById('messageArea').innerHTML = '';
            }
        }
        
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TruthTableGenerator();
        });
    </script>
</body>
</html>